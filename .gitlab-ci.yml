stages:
  - build
  - deploy
  - stop
  - commit
  - release
  - deploy_prod
  - stop_prod

variables:
  PROJECT_APP_IMAGE: $CI_REGISTRY_IMAGE/app
  TOKEN_REPO_WRITE_NAME: ci_push_token
  TOKEN_REPO_SELF_WRITE: "secret_value"
  TOKEN_API_SNIPPET_WRITE: "secret_value"
  SERVICE_NAME: ${CI_PROJECT_NAME}
  SUBDOMAIN: www
  AUTH_URL: ""
  MONGO_DB_NAME: citmp
  DEPLOY_SNIP_PROJECT_ID: 7
  DEPLOY_SNIP_ID: 33
  DEPLOY_SNIP_FILENAME: ENVS.txt
  USE_DEPLOY_SNIP: "true"
  TOKEN_API_GROUP_GAMES: "secret_value"
  TOKEN_API_PROJECT_NOTES: "secret_value"
  TOKEN_API_SELF_READ: "secret_value"
  GITLAB_API_URL: ${CI_API_V4_URL}
  BLOG_KEY: "secret_value"
  DEFAULT_GAME_BRANCH_REF: "master"
  BUILDKITD_POD: buildkitd-0
  BUILDKITD_NAMESPACE: buildkitd
  DOCKERFILE: Dockerfile
  GAME1_BRANCH_REF: "dev"

default:
  before_script:
  - SERVICE_NAME=${SERVICE_NAME//\./-}
  - SERVER_DOMAIN=${CI_SERVER_HOST//gitlab\./}

.apply_registry_secret: &apply_registry_secret
  - kubectl delete secret -n $KUBE_NAMESPACE gitlab-registry || true
  - kubectl create secret -n $KUBE_NAMESPACE docker-registry gitlab-registry
    --docker-server="$CI_REGISTRY" --docker-username="$CI_REGISTRY_USER"
    --docker-password="$CI_REGISTRY_PASSWORD" -o yaml --dry-run=client | kubectl apply -n $KUBE_NAMESPACE -f -

.create_docker_json: &create_docker_json
  - |
    mkdir ~/.docker && \
    cat <<EOF > ~/.docker/config.json
    {"auths":{"$CI_REGISTRY":{"auth":"$(echo -n ${CI_REGISTRY_USER}:${CI_REGISTRY_PASSWORD} | base64)"}}}
    EOF

.not_protected: &not_protected
  '$CI_COMMIT_REF_NAME != "dev" && $CI_COMMIT_REF_NAME != "master" && ($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web")'

.is_dev_branch: &is_dev_branch
  '$CI_COMMIT_REF_NAME == "dev" && ($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web")'

.is_web_master_stable: &is_web_master_stable
  '$CI_PIPELINE_SOURCE == "web" && $CI_COMMIT_REF_NAME == "master" && $RELEASE == null'

.is_web_master_release: &is_web_master_release
  '$CI_PIPELINE_SOURCE == "web" && $CI_COMMIT_REF_NAME == "master" && $RELEASE != null'

.trigger_deploy_prod_job: &trigger_deploy_prod_job
  - curl -X POST --form "variables[SKIP_BETA]=$SKIP_BETA"
    "${CI_SERVER_URL}/api/v4/projects/$CI_PROJECT_ID/trigger/pipeline?token=${CI_JOB_TOKEN}&ref=${CI_COMMIT_REF_NAME}"

.get_deploy_snippet: &get_deploy_snippet
  - curl "${CI_API_V4_URL}/projects/$DEPLOY_SNIP_PROJECT_ID/snippets/$DEPLOY_SNIP_ID/files/main/$DEPLOY_SNIP_FILENAME/raw" > $DEPLOY_SNIP_FILENAME

.update_deploy_snippet: &update_deploy_snippet
  - |
    cat <<EOF > snippet.json
    {"files":[{ "action": "update", "file_path": "$DEPLOY_SNIP_FILENAME","content" : "$(printf '%s\\n' $(<$DEPLOY_SNIP_FILENAME))"}]}
    EOF
  - 'curl -X PUT -H "PRIVATE-TOKEN: ${TOKEN_API_SNIPPET_WRITE}" -H "Content-Type: application/json" -d @snippet.json
    "${CI_API_V4_URL}/projects/$DEPLOY_SNIP_PROJECT_ID/snippets/$DEPLOY_SNIP_ID"'

.get_current_version: &get_current_version
  - DOCKER_SERVICE_NAME="main:"
  - PROD_IMAGE=$(awk "/${DOCKER_SERVICE_NAME}/{getline; print; exit;}" docker-compose.yml)
  - CURVER=$(echo $PROD_IMAGE | cut -d ":" -f3 | cut -d "-" -f1)

.exit_if_sha_matches_stable: &exit_if_sha_matches_stable
  - LAST_CI_SHA=$(git log --oneline | grep -A 1 "Stable\|Release" | cut -d " " -f1 | awk NR==1) || echo 0 # Last Stable/Release commit
  - echo $LAST_CI_SHA
  - "[[ $COMMIT_SHA = $LAST_CI_SHA ]] && exit 0"

.get_sha_to_build: &get_sha_to_build
  - COMMIT_SHA=$(git log -1 --pretty=format:%h)
  - STABLE_SHA=$(git log --oneline | grep -A 1 Stable | cut -d " " -f1 | awk NR==1) || echo 0 # Last Stable commit
  - RELEASE_SHA=$(git log --oneline | grep -A 1 Release | cut -d " " -f1 | awk NR==1) || echo 0 # Last Release commit
  - IMAGE_SHA=$(git log --oneline | grep -A 1 Stable | cut -d " " -f1 | awk NR==2) || echo 0 # Last docker-compose tag
    #Use commit. If commit matches stable use last image. If commit matches release rebuild release
  - SHA_TO_BUILD="-${COMMIT_SHA}"
  - '[[ $COMMIT_SHA = $STABLE_SHA ]] && SHA_TO_BUILD="-$IMAGE_SHA"'
  - '[[ $COMMIT_SHA = $RELEASE_SHA ]] && SHA_TO_BUILD=""'
  - echo $COMMIT_SHA $IMAGE_SHA $STABLE_SHA $RELEASE_SHA

.create_rc: &create_rc
  - *get_current_version
  - MAJOR_MINOR=$(echo $CURVER | cut -d "." -f 1-2)
  - PATCH=$(echo $CURVER | cut -d "." -f 3)
  - NEXT_PATCH=$(($PATCH + 1))
  - RC=${MAJOR_MINOR}.${NEXT_PATCH}-rc

.create_next_version: &create_next_version
  - *get_current_version
  - MAJOR=$(echo $CURVER | cut -d "." -f 1)
  - MINOR=$(echo $CURVER | cut -d "." -f 2)
  - PATCH=$(echo $CURVER | cut -d "." -f 3)
  - NEXT_MAJOR=$(($MAJOR + 1))
  - NEXT_MINOR=$(($MINOR + 1))
  - NEXT_PATCH=$(($PATCH + 1))
  - "[[ $RELEASE == 'major' ]] && VERSION=${NEXT_MAJOR}.0.0"
  - "[[ $RELEASE == 'minor' ]] && VERSION=${MAJOR}.${NEXT_MINOR}.0"
  - "[[ $RELEASE == 'patch' ]] && VERSION=${MAJOR}.${MINOR}.${NEXT_PATCH}"

## Most likely be using skaffold + buildctl in script next
## TODO: Support using multiple --build-arg
.build_image: &build_image
  #- skaffold build
  - buildctl --addr kube-pod://${BUILDKITD_POD}?namespace=${BUILDKITD_NAMESPACE} build
    --frontend dockerfile.v0 --local dockerfile=. --local context=.
    --opt target=${BUILD_TARGET} --opt filename=./${DOCKERFILE}
    --output type=image,\"name=${OUTPUT_IMGS}\",push=true
    --export-cache type=inline
    ${IMPORT_CACHE_ARGS}

.create_helm_values: &create_helm_values
  - |
    REGISTER_SERVICE="false"
    ENABLE_DB="false"
    [[ $KUBE_NAMESPACE = "production" ]] && REGISTER_SERVICE="true"
    ### Almost to temp ci dbs in helm
    [[ $KUBE_NAMESPACE = "production" ]] && ENABLE_DB="false"
    cat <<EOF > helm_ci_values.yaml
    imagePullSecrets:
      - name: gitlab-registry
    image:
      repository: "${PROJECT_APP_IMAGE}"
      tag: "${HELM_IMAGE_TAG}"
    ciLabels:
      app: "${APPNAME}"
      env: "${CI_ENVIRONMENT_SLUG}"
    ciAnnotations:
      app.gitlab.com/app: "${CI_PROJECT_PATH_SLUG}"
      app.gitlab.com/env: "${CI_ENVIRONMENT_SLUG}"
    secretStringData:
      MONGO_DB_NAME: "${MONGO_DB_NAME}"
      BLOG_KEY: "${BLOG_KEY}"
      TOKEN_API_SELF_READ: "${TOKEN_API_SELF_READ}"
    configMapData:
      REGISTER_SERVICE:     "${REGISTER_SERVICE}"
      AUTH_URL:             "${AUTH_URL}"
      DEV_DATABASE_URL:     ""
      GITLAB_API_URL:       "${GITLAB_API_URL}"
      ENABLE_DB:            "${ENABLE_DB}"
    EOF

.deploy_helm_chart: &deploy_helm_chart
  - '[[ -n $HELM_IMAGE_TAG ]] && sed -i "s|appVersion: .*|appVersion: \"${HELM_IMAGE_TAG}\"|" helmchart/Chart.yaml'
  #- skaffold deploy
  - helm upgrade $APPNAME helmchart --install -f helm_ci_values.yaml -n $KUBE_NAMESPACE --wait
  - helm history $APPNAME -n $KUBE_NAMESPACE
  - kubectl rollout status -w "deployment/${APPNAME}" -n $KUBE_NAMESPACE
  - kubectl rollout status -w "deployment/${APPNAME}-tmpdb" -n $KUBE_NAMESPACE || echo 0
  - kubectl get deploy,svc,pod -n $KUBE_NAMESPACE

.add_md: &add_md
  - 'ARTIFACTS_URL="$CI_SERVER_URL/api/v4/projects/100/jobs/artifacts/master/download?job=bundle"'
  - 'curl -JO --header "PRIVATE-TOKEN: $TOKEN_API_PROJECT_NOTES" "$ARTIFACTS_URL"'
  - unzip -o artifacts.zip -d ./server/static/md/
  - rm -rf artifacts.zip

.add_game: &add_game
  - 'ARTIFACTS_URL="$CI_SERVER_URL/api/v4/projects/$PROJECT_ID/jobs/artifacts/$BRANCH_REF/download?job=build_webgl"'
  - 'curl -JO --header "PRIVATE-TOKEN: $TOKEN_API_GROUP_GAMES" "$ARTIFACTS_URL"'
  - 'COMMIT_URL="$CI_SERVER_URL/api/v4/projects/$PROJECT_ID/repository/commits/$BRANCH_REF"'
  - 'GAME_SHA=$(curl --header "PRIVATE-TOKEN: $TOKEN_API_GROUP_GAMES" "$COMMIT_URL" | jq ".id")'
  - echo $GAME_SHA
  - 'GAME_FOLDER=$(unzip -l artifacts.zip | sed -n "s|\/||;1p")'
  - echo "window.GAMES[\"$GAME_FOLDER\"] = $GAME_SHA" >> ./src/config/globals.js
  - unzip -o artifacts.zip -d ./server/static/unity
  - rm -rf artifacts.zip

.game1: &game1
  - PROJECT_ID=99
  - "[[ -n $GAME1_BRANCH_REF ]] && BRANCH_REF=$GAME1_BRANCH_REF"
  - *add_game
.game2: &game2
  - PROJECT_ID=63
  - TOKEN_API_GROUP_GAMES=$TOKEN_API_PROJECT_GAME2
  - "[[ -n $GAME2_BRANCH_REF ]] && BRANCH_REF=$GAME2_BRANCH_REF"
  - *add_game
.game3: &game3
  - PROJECT_ID=98
  - "[[ -n $GAME3_BRANCH_REF ]] && BRANCH_REF=$GAME3_BRANCH_REF"
  - *add_game
.game4: &game4
  - PROJECT_ID=97
  - "[[ -n $GAME4_BRANCH_REF ]] && BRANCH_REF=$GAME4_BRANCH_REF"
  - *add_game
.game5: &game5
  - PROJECT_ID=95
  - "[[ -n $GAME5_BRANCH_REF ]] && BRANCH_REF=$GAME5_BRANCH_REF"
  - *add_game
.game6: &game6
  - PROJECT_ID=96
  - "[[ -n $GAME6_BRANCH_REF ]] && BRANCH_REF=$GAME6_BRANCH_REF"
  - *add_game

.add_games: &add_games
  - BRANCH_REF=$DEFAULT_GAME_BRANCH_REF
  - *game1
  - *game2
  - *game3
    #- *game4
  - *game5
    #- *game6

workflow:
  rules:
  - if: $CI_COMMIT_TAG
    when: never
  - if: '$ONLY_DEPLOY_PROD == "true" || $STOP_PROD == "true"'
    variables:
      SKIP_WEB_DEFAULT_RUN: "true"
  - when: always

echo_env_vars:
  stage: build
  tags:
  - kubernetes_builder
  script:
  - echo $CI_PIPELINE_SOURCE
  - echo $CI_COMMIT_REF_NAME
  - echo $CI_DEFAULT_BRANCH
  - echo $CI_COMMIT_SHORT_SHA
  - echo $CI_SERVER_URL
  - echo $CI_REGISTRY_IMAGE
  - echo $CI_PROJECT_URL
  - echo $CI_PROJECT_NAMESPACE
  - echo $CI_PROJECT_NAME
  - echo $CI_PROJECT_PATH
  - echo $CI_PROJECT_ID
  - echo $CI_KUBERNETES_ACTIVE
  - echo $CI_CONFIG_PATH
  rules:
  - if: $CI_PIPELINE_SOURCE != "merge_request_event"


########################
#### FEATURE BRANCH
########################
build_review:
  stage: build
  tags:
  - kubernetes_builder
  variables:
    BUILD_TARGET: src
    IMPORT_CACHE_ARGS: |
      --import-cache type=registry,ref=${PROJECT_APP_IMAGE}:dev
  script:
  - *create_docker_json
  - "OUTPUT_IMGS=${PROJECT_APP_IMAGE}:${CI_COMMIT_SHORT_SHA}"
  - *add_md
  - *add_games
  - *build_image
  rules:
  - if: $CI_PIPELINE_SOURCE != "push" && $CI_PIPELINE_SOURCE != "web"
    when: never
  - if: *not_protected

deploy_review:
  stage: deploy
  tags:
  - kubernetes
  variables:
    KUBE_NAMESPACE: review
  script:
  - echo "$KUBE_NAMESPACE"
  - APPNAME=${CI_ENVIRONMENT_SLUG}-${SERVICE_NAME}
  - HELM_IMAGE_TAG=${CI_COMMIT_SHORT_SHA}
  - KUBE_INGRESS_BASE_DOMAIN=dev.${SERVER_DOMAIN}
  - 'URL=http://${CI_ENVIRONMENT_SLUG}.${KUBE_NAMESPACE}.${SUBDOMAIN}.${KUBE_INGRESS_BASE_DOMAIN}'
  - echo "URL=${URL}" > deploy.env
  - 'echo "APPNAME: ${APPNAME}"'
  - 'echo "URL: ${URL}"'
  - *apply_registry_secret
  - *create_helm_values
  - *deploy_helm_chart
  artifacts:
    reports:
      dotenv: deploy.env 
  environment:
    name: review/$CI_COMMIT_REF_NAME
    url: $URL
    on_stop: stop_review
    auto_stop_in: 1 hour
  rules:
  - if: *not_protected

stop_review:
  stage: stop
  tags:
  - kubernetes
  variables:
    KUBE_NAMESPACE: review
    GIT_STRATEGY: none
  script:
  - echo "Stop commit"
  - echo "$KUBE_NAMESPACE"
  - APPNAME=${CI_ENVIRONMENT_SLUG}-${SERVICE_NAME}
  - helm uninstall $APPNAME -n $KUBE_NAMESPACE || true
  environment:
    name: review/$CI_COMMIT_REF_NAME
    action: stop
  rules:
  - if: *not_protected
    when: manual


########################
########################
#### DEV BRANCH
########################
########################

build_rc:
  stage: build
  tags:
  - kubernetes_builder_prod
  variables:
    BUILD_TARGET: src
    IMPORT_CACHE_ARGS: |
      --import-cache type=registry,ref=${PROJECT_APP_IMAGE}:dev
  script:
  - *create_docker_json
  - *add_md
  - *add_games
  - *create_rc
  - 'IMPORT_CACHE_ARGS="${IMPORT_CACHE_ARGS} --import-cache type=registry,ref=${PROJECT_APP_IMAGE}:$RC"'
  - "OUTPUT_IMGS=${PROJECT_APP_IMAGE}:dev"
  - *build_image
  - BUILD_TARGET=prod
  - "OUTPUT_IMGS=${PROJECT_APP_IMAGE}:$RC"
  - *build_image
  rules:
  - if: *is_dev_branch

deploy_rc:
  stage: deploy
  tags:
  - kubernetes_prod
  variables:
    KUBE_NAMESPACE: dev
  script:
  - *create_rc
  - echo "$KUBE_NAMESPACE"
  - APPNAME=${SERVICE_NAME}
  - HELM_IMAGE_TAG=${RC}
  - KUBE_INGRESS_BASE_DOMAIN=dev.${SERVER_DOMAIN}
  - 'URL=http://${SUBDOMAIN}.${KUBE_INGRESS_BASE_DOMAIN}'
  - echo "URL=${URL}" > deploy.env
  - 'echo "APPNAME: ${APPNAME}"'
  - 'echo "URL: ${URL}"'
  - *apply_registry_secret
  - *create_helm_values
  - *deploy_helm_chart
  artifacts:
    reports:
      dotenv: deploy.env 
  environment:
    name: dev
    url: $URL
    on_stop: stop_rc
    auto_stop_in: 1 hour
  rules:
  - if: *is_dev_branch

stop_rc:
  stage: stop
  tags:
  - kubernetes_prod
  variables:
    KUBE_NAMESPACE: dev
    GIT_STRATEGY: none
  script:
  - echo "Stop rc"
  - echo "$KUBE_NAMESPACE"
  - APPNAME=${SERVICE_NAME}
  - helm uninstall $APPNAME -n $KUBE_NAMESPACE || true
  environment:
    name: dev
    action: stop
  rules:
  - if: *is_dev_branch
    when: manual


########################
########################
#### MASTER BRANCH
########################
########################

### Only build on each new push to master
build_beta:
  stage: build
  tags:
  - kubernetes_builder_prod
  variables:
    BUILD_TARGET: prod
    IMPORT_CACHE_ARGS: |
      --import-cache type=registry,ref=${PROJECT_APP_IMAGE}:dev
  script:
  - *create_docker_json
  - *add_md
  - *add_games
  - *create_rc
  - 'IMPORT_CACHE_ARGS="${IMPORT_CACHE_ARGS} --import-cache type=registry,ref=${PROJECT_APP_IMAGE}:$RC"'
  - "OUTPUT_IMGS=${PROJECT_APP_IMAGE}:${RC}-beta"
  - *build_image
  rules:
  - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME == "master"
  - if: $BUILD_BETA == "true" && $CI_PIPELINE_SOURCE == "web" && $CI_COMMIT_REF_NAME == "master"

#### Cannot manually web run directly after a release without BUILD_BETA, no properly tagged beta build (nothing new)
#### The point is to capture the merge/push to master to prepare for release (possibly start doing a release branch)
#### Beta environment can be restarted from gitlab UI
deploy_beta:
  stage: deploy
  tags:
  - kubernetes_prod
  variables:
    KUBE_NAMESPACE: beta
  script:
  - *create_rc
  - echo "$KUBE_NAMESPACE"
  - APPNAME=${SERVICE_NAME}
  - HELM_IMAGE_TAG=${RC}-beta
  - KUBE_INGRESS_BASE_DOMAIN=beta.${SERVER_DOMAIN}
  - 'URL=https://${SUBDOMAIN}.${KUBE_INGRESS_BASE_DOMAIN}'
  - echo "URL=${URL}" > deploy.env
  - 'echo "APPNAME: ${APPNAME}"'
  - 'echo "URL: ${URL}"'
  - *apply_registry_secret
  - *create_helm_values
  - *deploy_helm_chart
  artifacts:
    reports:
      dotenv: deploy.env 
  environment:
    name: beta
    url: $URL
    on_stop: stop_beta
    auto_stop_in: 1 hour
  rules:
  - if: '$SKIP_WEB_DEFAULT_RUN == "true"'
    when: never
  - if: '$SKIP_BETA == "true" ||  $RELEASE != null'
    when: never
  - if: ($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web") && $CI_COMMIT_REF_NAME == "master"

stop_beta:
  stage: stop
  tags:
  - kubernetes_prod
  variables:
    KUBE_NAMESPACE: beta
    GIT_STRATEGY: none
  script:
  - echo "Stop beta"
  - echo "$KUBE_NAMESPACE"
  - APPNAME=${SERVICE_NAME}
  - helm uninstall $APPNAME -n $KUBE_NAMESPACE || true
  environment:
    name: beta
    action: stop
  rules:
  - if: '$SKIP_WEB_DEFAULT_RUN == "true"'
    when: never
  - if: '$SKIP_BETA == "true" ||  $RELEASE != null || $KEEP_BETA != null'
    when: never
  - if: ($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web") && $CI_COMMIT_REF_NAME == "master"
    when: manual

###############################
###   Not Tag Commit  -  $RELEASE is not defined
###############################
commit_stable:
  stage: commit
  tags:
  - kubernetes_builder_prod
  script:
  - *get_current_version
  - echo $CURVER
  - COMMIT_SHA=$(git log -1 --pretty=format:%h)
  - echo $COMMIT_SHA
  - *exit_if_sha_matches_stable
  - sed -i "s|${CURVER}-*.*|${CURVER}-${COMMIT_SHA}|" docker-compose.yml
  - 'sed -i "s|appVersion: \"${CURVER}-*.*\"|appVersion: \"${CURVER}-${COMMIT_SHA}\"|" helmchart/Chart.yaml'
  - git add docker-compose.yml helmchart/Chart.yaml
  - git config --global user.name "${GITLAB_USER_NAME}"
  - git config --global user.email "${GITLAB_USER_EMAIL}"
  - 'git commit -m "Stable: ${CURVER}-${COMMIT_SHA}" --author="GitLab Runner <gitlab-runner@${CI_SERVER_HOST}>" -s'
  - 'git remote set-url origin https://${TOKEN_REPO_WRITE_NAME}:${TOKEN_REPO_SELF_WRITE}@$CI_SERVER_HOST/${CI_PROJECT_PATH}.git'
  - git push -o ci.skip origin HEAD:master
  rules:
  - if: '$SKIP_WEB_DEFAULT_RUN == "true"'
    when: never
  - if: '$SKIP_BETA == "true" && $CI_PIPELINE_SOURCE == "web" && $CI_COMMIT_REF_NAME == "master" && $RELEASE == null'
    when: on_success
  - if: *is_web_master_stable
    when: manual

release_stable:
  stage: release
  tags:
  - kubernetes_builder_prod
  variables:
    BUILD_TARGET: prod
    IMPORT_CACHE_ARGS: |
      --import-cache type=registry,ref=${PROJECT_APP_IMAGE}:dev
  script:
  - *create_docker_json
  - *add_md
  - *add_games
  - *create_rc
  - echo $CURVER
  - echo $RC
  - *get_sha_to_build
  - echo $SHA_TO_BUILD
  ##! We update tag in docker-compose.yml cause we build it into the image for consul to get the current tag
  ##! Once we do a consul side-loaded container in helm for apps or something we can probably finally remove
  - sed -i "s|${CURVER}-*.*|${CURVER}${SHA_TO_BUILD}|" docker-compose.yml
  - 'IMPORT_CACHE_ARGS="${IMPORT_CACHE_ARGS} --import-cache type=registry,ref=${PROJECT_APP_IMAGE}:${RC}-beta"'
  - "OUTPUT_IMGS=${PROJECT_APP_IMAGE}:${CURVER}${SHA_TO_BUILD},${PROJECT_APP_IMAGE}:latest,${PROJECT_APP_IMAGE}:${CURVER}-stable"
  - *build_image
  - *trigger_deploy_prod_job
  rules:
  - if: '$SKIP_WEB_DEFAULT_RUN == "true"'
    when: never
  - if: *is_web_master_stable



###############################
###   Tag Version Commit -  $RELEASE is defined
###############################
commit_version:
  stage: commit
  tags:
  - kubernetes_builder_prod
  script:
  - echo $RELEASE
  - *create_next_version
  - echo $CURVER
  - echo ${VERSION}
  ### Think this was when it was private - its also used as an env var but can be removed soon
  #- 'curl -H "PRIVATE-TOKEN: ${TOKEN_API_SELF_READ}"
  - 'curl "${CI_API_V4_URL}/projects/$CI_PROJECT_ID/merge_requests?state=merged&target_branch=$CI_DEFAULT_BRANCH" > mreq.json'
  - curl -O $CI_SERVER_URL/os/changelogger/-/raw/master/genlog.sh
  - bash genlog.sh $RELEASE -s $CI_SERVER_URL -p $CI_PROJECT_PATH -t $CURVER -v -m mreq.json -n $NOTES
  - git add CHANGELOG.md 2>/dev/null || echo 0
  - sed -i "s|${CURVER}-*.*|${VERSION}|" docker-compose.yml
  - 'sed -i "s|appVersion: \"${CURVER}-*.*\"|appVersion: \"${VERSION}\"|" helmchart/Chart.yaml'
  - git add docker-compose.yml helmchart/Chart.yaml
  - git config --global user.name "${GITLAB_USER_NAME}"
  - git config --global user.email "${GITLAB_USER_EMAIL}"
  - 'git commit -m "Release: ${VERSION}" --author="GitLab Runner <gitlab-runner@${CI_SERVER_HOST}>" -s'
  - git tag ${VERSION}
  - 'git remote set-url origin https://${TOKEN_REPO_WRITE_NAME}:${TOKEN_REPO_SELF_WRITE}@$CI_SERVER_HOST/${CI_PROJECT_PATH}.git'
  - git push -o ci.skip origin HEAD:master --tags
  rules:
  - if: '$SKIP_WEB_DEFAULT_RUN == "true"'
    when: never
  - if: '$SKIP_BETA == "true" && $CI_PIPELINE_SOURCE == "web" && $CI_COMMIT_REF_NAME == "master" && $RELEASE != null'
    when: on_success
  - if: *is_web_master_release
    when: manual

release_version:
  stage: release
  tags:
  - kubernetes_builder_prod
  variables:
    BUILD_TARGET: prod
    IMPORT_CACHE_ARGS: |
      --import-cache type=registry,ref=${PROJECT_APP_IMAGE}:dev
  script:
  - *create_docker_json
  - *add_md
  - *add_games
  - echo $RELEASE
  - *create_rc
  - *create_next_version
  - echo $CURVER
  - echo $RC
  - echo ${VERSION}
  ##! We update tag in docker-compose.yml cause we build it into the image for consul to get the current tag
  ##! Once we do a consul side-loaded container in helm for apps or something we can probably finally remove
  - sed -i "s|${CURVER}-*.*|${VERSION}|" docker-compose.yml
  - 'IMPORT_CACHE_ARGS="${IMPORT_CACHE_ARGS} --import-cache type=registry,ref=${PROJECT_APP_IMAGE}:${RC}-beta"'
  - 'IMPORT_CACHE_ARGS="${IMPORT_CACHE_ARGS} --import-cache type=registry,ref=${PROJECT_APP_IMAGE}:${CURVER}-stable"'
  - "OUTPUT_IMGS=${PROJECT_APP_IMAGE}:$VERSION,${PROJECT_APP_IMAGE}:latest"
  - *build_image
  - *trigger_deploy_prod_job
  rules:
  - if: '$SKIP_WEB_DEFAULT_RUN == "true"'
    when: never
  - if: *is_web_master_release



###############################
###   Deploy from master branch
###############################


deploy_production:
  stage: deploy_prod
  tags:
  - kubernetes_prod
  variables:
    KUBE_NAMESPACE: production
    AUTH_URL: ${CI_SERVER_URL}
  script:
  - echo "$KUBE_NAMESPACE"
  - APPNAME=${SERVICE_NAME}
  - HELM_IMAGE_TAG=""
  - 'URL=https://${SUBDOMAIN}.${SERVER_DOMAIN}'
  - echo "URL=${URL}" > deploy.env
  - 'echo "APPNAME: ${APPNAME}"'
  - 'echo "URL: ${URL}"'
  - *apply_registry_secret
  - *create_helm_values
  - *deploy_helm_chart
  - '[[ -z $USE_DEPLOY_SNIP || $USE_DEPLOY_SNIP != "true" ]] && exit 0'
  - *get_deploy_snippet
  - FOUND_ID=$(sed -n "/^$CI_PROJECT_ID$/p" $DEPLOY_SNIP_FILENAME)
  - '[[ -n $FOUND_ID ]] && exit 0'
  - echo "$CI_PROJECT_ID" >> $DEPLOY_SNIP_FILENAME
  - *update_deploy_snippet
  artifacts:
    reports:
      dotenv: deploy.env 
  environment:
    name: production
    url: $URL
  rules:
  - if: $ONLY_DEPLOY_PROD == "true"
    when: always
  - if: '$SKIP_BETA == "true" && $CI_PIPELINE_SOURCE == "pipeline" && $CI_COMMIT_REF_NAME == "master"'
    when: on_success
  - if: '$CI_PIPELINE_SOURCE == "pipeline" && $CI_COMMIT_REF_NAME == "master"'
    when: manual


stop_production:
  stage: stop_prod
  tags:
  - kubernetes_prod
  variables:
    KUBE_NAMESPACE: production
    GIT_STRATEGY: none
  script:
  - echo "Stop prod"
  - echo "$KUBE_NAMESPACE"
  - APPNAME=${SERVICE_NAME}
  - helm uninstall $APPNAME -n $KUBE_NAMESPACE || true
  - '[[ -z $USE_DEPLOY_SNIP || $USE_DEPLOY_SNIP != "true" ]] && exit 0'
  - *get_deploy_snippet
  - sed -i "/^$CI_PROJECT_ID$/d" $DEPLOY_SNIP_FILENAME
  - *update_deploy_snippet
  environment:
    name: production
    action: stop
  rules:
  - if: '$STOP_PROD == "true" && $CI_PIPELINE_SOURCE == "web" && $CI_COMMIT_REF_NAME == "master"'

## TODO: Either we configure an elevated runner to delete the tmp namespace after stop/merge (if possible).
##  Or we run a single project namespace for the review cluster (we setup 4, review dev beta prod. 3 are not gitlab managed)
## Only concern with NS-per-env is if we delete the env and a duplicate gets made will it cause an issue (seemed so before) - needs testing
.cleanup:
  stage: clean
  script:
  - echo "CLEAN"
  rules:
  - if: '$CI_PIPELINE_SOURCE == "web" && $CI_COMMIT_REF_NAME != "dev" && $CI_COMMIT_REF_NAME != "master"'
    when: manual
